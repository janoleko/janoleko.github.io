<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>LaMa and RTMB</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="LaMa_and_RTMB_files/libs/clipboard/clipboard.min.js"></script>
<script src="LaMa_and_RTMB_files/libs/quarto-html/quarto.js"></script>
<script src="LaMa_and_RTMB_files/libs/quarto-html/popper.min.js"></script>
<script src="LaMa_and_RTMB_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="LaMa_and_RTMB_files/libs/quarto-html/anchor.min.js"></script>
<link href="LaMa_and_RTMB_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="LaMa_and_RTMB_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="LaMa_and_RTMB_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="LaMa_and_RTMB_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="LaMa_and_RTMB_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">LaMa and RTMB</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The recently introduced <code>R</code> package <code>RTMB</code> conveniently allows for automatic differentiation for non-standard statistical models written in plain <code>R</code> code. This enables the estimation of very complicated models, potentially with complex random effect structures. The process feels like magic because you have access to analytic gradients – <em>drastically</em> increasing accuracy and speed – without doing any calculations!</p>
<p><code>LaMa</code> now also allows for automatic differentiation with <code>RTMB</code> for most of its functions when you set <code>ad = TRUE</code>. Hence, estimation of latent Markov models is now faster and more convenient, while model specification is very smooth and less prone to errors – which at the current state tend to happen when one is not experienced with <code>RTMB</code>.</p>
<p>Here we demonstrate how to use <code>LaMa</code> and <code>RTMB</code> to fit hidden Markov models and their extensions. We always start by loading both packages.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(LaMa) <span class="co"># development version</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RTMB)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For the purpose of this vignette, we will analyze the <code>elephant</code> data set contained in the <code>LaMa</code> package:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(elephant, <span class="dv">5</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   tod      step     angle state</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1   9 0.3252437        NA     1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2  10 0.2458265  2.234562     1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3  11 0.2173252 -2.262418     1</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4  12 0.5114665 -2.958732     1</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5  13 0.3828494  1.811840     1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="basic-workflow" class="level3">
<h3 class="anchored" data-anchor-id="basic-workflow">Basic workflow</h3>
<p>The workflow with <code>RTMB</code> is basically always the same. We need to</p>
<ul>
<li>define the negative log-likelihood function,</li>
<li>create an automatically differentiable objective function from it and</li>
<li>fit the model by numerical minimization of the latter.</li>
</ul>
<p><code>RTMB</code> also provides many functions that make this process very convenient.</p>
</section>
<section id="simple-hmm" class="level3">
<h3 class="anchored" data-anchor-id="simple-hmm">Simple HMM</h3>
<p>We start by fitting a super simple stationary HMM with state-dependent gamma distributions for the step lengths and von Mises distributions for the turning angles. As a first step, we define the initial parameter list <code>par</code> and a <code>dat</code> list that contains the data and potential hyperparamters – here <span class="math inline">\(N\)</span>, the number of hidden states. The names <code>par</code> and <code>dat</code> are of course arbitrary.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>par <span class="ot">=</span> <span class="fu">list</span>(<span class="at">logmu =</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="fl">0.3</span>, <span class="dv">1</span>)),      <span class="co"># initial means for step length (log-transformed)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">logsigma =</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="fl">0.2</span>, <span class="fl">0.7</span>)), <span class="co"># initial sds for step length (log-transformed)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">logkappa =</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="fl">0.2</span>, <span class="fl">0.7</span>)), <span class="co"># initial concentration for turning angle (log-transformed)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>           <span class="at">eta =</span> <span class="fu">rep</span>(<span class="sc">-</span><span class="dv">2</span>, <span class="dv">2</span>))            <span class="co"># initial t.p.m. parameters (on logit scale)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">=</span> <span class="fu">list</span>(<span class="at">step =</span> elephant<span class="sc">$</span>step, <span class="at">angle =</span> elephant<span class="sc">$</span>angle, <span class="at">N =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As <code>par</code> is a named list or initial parameter values, accessing the parameters later on and much more convenient than indexing. You could also use a parameter vector with <code>RTMB</code>, but using a named list makes our life so much easier.</p>
<p>We can now define the negative log-likelihood function in a similar fashion to basic numerical ML</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>mllk <span class="ot">=</span> <span class="cf">function</span>(par) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">getAll</span>(par, dat) <span class="co"># makes everything contained available without $</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  Gamma <span class="ot">=</span> <span class="fu">tpm</span>(eta) <span class="co"># computes transition probability matrix from unconstrained eta</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  delta <span class="ot">=</span> <span class="fu">stationary</span>(Gamma) <span class="co"># computes stationary distribution</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># exponentiating because all parameters strictly positive</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">=</span> <span class="fu">exp</span>(logmu)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  sigma <span class="ot">=</span> <span class="fu">exp</span>(logsigma)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  kappa <span class="ot">=</span> <span class="fu">exp</span>(logkappa)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># reporting statements for later use</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">REPORT</span>(mu); <span class="fu">ADREPORT</span>(mu)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">REPORT</span>(sigma); <span class="fu">ADREPORT</span>(sigma)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">REPORT</span>(kappa); <span class="fu">ADREPORT</span>(kappa)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># calculating all state-dependent densities</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  allprobs <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">1</span>, <span class="at">nrow =</span> <span class="fu">length</span>(step), <span class="at">ncol =</span> N)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  ind <span class="ot">=</span> <span class="fu">which</span>(<span class="sc">!</span><span class="fu">is.na</span>(step) <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.na</span>(angle)) <span class="co"># only for non-NA obs.</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N){</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    allprobs[ind,j] <span class="ot">=</span> <span class="fu">dgamma2</span>(step[ind],mu[j],sigma[j])<span class="sc">*</span><span class="fu">dvm</span>(angle[ind],<span class="dv">0</span>,kappa[j])</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  <span class="sc">-</span><span class="fu">forward</span>(delta, Gamma, allprobs, <span class="at">ad =</span> <span class="cn">TRUE</span>) <span class="co"># simple forward algorithm</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>but a few points should be made here:</p>
<ul>
<li>Most prominently, the negative log-likelihood is a function of the parameters to be estimated <em>only</em> while data and other parameters are not passed as an argument at this stage. This is something to get used to (I know), but just the way <code>RTMB</code> works.</li>
<li>The <code>getAll()</code> function is very useful and you should use it in the first line to unpack both the <code>par</code> and the <code>dat</code> list, making all elements available without the <code>$</code> operator. At this stage, <code>mllk</code> just takes the dat object from the global environment.</li>
<li>Parameter transformations are of course still necessary, i.e.&nbsp;all parameters in <code>par</code> should be unconstrained.</li>
<li>Simple <code>LaMa</code> functions (like <code>tpm()</code> or <code>stationary()</code>) work for both automatic differentiation and standard optimization. For the more complicated functions like <code>forward()</code> you currently need to specify <code>ad = TRUE</code> to get automatic differentiation. I would like to make this smoother in the future, but that’s where we’re at at the moment. Whenever you are not sure if you need <code>ad = TRUE</code>, check the documentation.</li>
<li>You might wonder how on earth <code>RTMB</code> can calculate the gradient of parameters in distributions like the gamma or von Mises distribution. The answer is: It can’t but provides its own version of all standard distributions like <code>dnorm()</code>, <code>dbinom()</code>, etc. In this case both <code>dgamma2()</code> and <code>dvm()</code> come from <code>LaMa</code> as these are non-standard, but under the hood build on <code>RTMB</code> functions (<code>dgamma2()</code> is actually just a convenience function that reparametrizes the gamma distribution in terms of mean and standard deviation).</li>
<li>Actually, most of the standard functions (e.g.&nbsp;<code>sum()</code>), operators (e.g.&nbsp;<code>%*%</code>) and methods (e.g.&nbsp;<code>matrix</code>) are overwritten when you use <code>RTMB</code> but you typically don’t notice that and should not care – but this is how the magic works.</li>
<li>the <code>REPORT()</code> function offered by <code>RTMB</code> is really convenient as any quantities calculated in the likelihood function (for which you have written the code anyway), if reported, will be available after optimization, while the report statements are ignored during optimization. So no annoying backtransformations anymore, wohoo!</li>
<li>for simple parameter transformations, <code>ADREPORT()</code> is also great, because it calculates standard deviations for <code>ADREPORT()</code>ed quantities, based on the delta method. Just note that the delta method is not advisable for complex non-linear and multivariate transformations.</li>
</ul>
<p>Having defined the negative log-likelihood, we can now create the autmatically differentiable objective function and fit the model. This needs a little explanation: At this point, <code>RTMB</code> takes the negative log-likelihood function and generates its own version of it, including a gradient. <code>MakeADFun()</code> now also grabs whatever is saved as <code>dat</code> in the global environment and <em>bakes</em> it into the objective function. Therefore, changes to <code>dat</code> after this point will have no effect on the optimization result. We set <code>silent = TRUE</code> to suppress printing of the optimization process.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>obj <span class="ot">=</span> <span class="fu">MakeADFun</span>(mllk, par, <span class="at">silent =</span> <span class="cn">TRUE</span>) <span class="co"># creating the objective function</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s check out <code>obj</code>:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(obj)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  [1] "par"      "fn"       "gr"       "he"       "hessian"  "method"  </span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  [7] "retape"   "env"      "report"   "simulate"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It contains the initial parameter <code>par</code> (now tranformed to a vector), the objective function <code>fn</code> (which in this case just evaluates <code>mllk</code> but faster), its gradient <code>gr</code> and Hessian <code>he</code>.</p>
<p>If we now call these functions without any argument, we get the corresponding values at the initial parameter vector.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>obj<span class="sc">$</span>par</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      logmu      logmu   logsigma   logsigma   logkappa   logkappa        eta </span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; -1.2039728  0.0000000 -1.6094379 -0.3566749 -1.6094379 -0.3566749 -2.0000000 </span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;        eta </span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; -2.0000000</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>obj<span class="sc">$</span><span class="fu">fn</span>()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 33293.84</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>obj<span class="sc">$</span><span class="fu">gr</span>()</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;          [,1]      [,2]     [,3]      [,4]     [,5]      [,6]     [,7]</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] 573.7198 -2467.274 95.35893 -12045.97 55.92507 -807.9504 134.0732</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           [,8]</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] -181.2148</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We are now ready to optimize the objective function. The optimization routine <code>nlminb()</code> is very robust and conveniently allows us to provide a gradient function. Alternatively, you can also use <code>optim()</code> or any other optimizer you like that allows you to pass a gradient function.</p>
<p>Indeed, we do not provide the Hessian to <code>nlminb()</code> because while evaluating the Hessian is very fast with <code>RTMB</code>, optimization is still much faster if we use a quasi-Newton algorithm that approximates the current Hessian based on previous gradient evaluations, compared to using full Newton-Raphson.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>opt <span class="ot">=</span> <span class="fu">nlminb</span>(obj<span class="sc">$</span>par, obj<span class="sc">$</span>fn, obj<span class="sc">$</span>gr) <span class="co"># optimization</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can check out the estimated parameter and function value by</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>opt<span class="sc">$</span>par</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      logmu      logmu   logsigma   logsigma   logkappa   logkappa        eta </span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; -1.1916144  0.9182131 -1.5995349  0.3999258 -2.2872716  0.4019563 -1.6621910 </span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;        eta </span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; -1.5735921</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>opt<span class="sc">$</span>objective</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 27248.59</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that the naming here is determined by <code>nlminb()</code>. If you use a different optimizer, these may be called differently.</p>
<p>Much nicer however, is that <code>obj</code> (yes <code>obj</code> not <code>opt</code>) is automatically updated after the optimization. Note that calling <code>obj$gr()</code> after optimization now gives the gradient at the optimum, while <code>obj$fn()</code> still gives the objective at the starting value and <code>obj$par</code> is not updated but still the initial parameter vector (kind of confusing).</p>
<p>To get our estimated parameters on their natural scale, we don’t have to do the backtransformation manually. We can just run the reporting:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>mod <span class="ot">=</span> obj<span class="sc">$</span><span class="fu">report</span>() <span class="co"># runs the reporting from the negative log-likelihood once</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>(<span class="at">delta =</span> mod<span class="sc">$</span>delta)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  state 1  state 2 </span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 0.481525 0.518475</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>(<span class="at">Gamma =</span> mod<span class="sc">$</span>Gamma)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           [,1]      [,2]</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] 0.8282951 0.1717049</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,] 0.1594681 0.8405319</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>(<span class="at">mu =</span> mod<span class="sc">$</span>mu)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.3037305 2.5048106</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>(<span class="at">sigma =</span> mod<span class="sc">$</span>sigma)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.2019904 1.4917139</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>(<span class="at">kappa =</span> mod<span class="sc">$</span>kappa)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.1015431 1.4947460</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>which works because of the <code>REPORT()</code> statements in the likelihood function. Note that <code>delta</code>, <code>Gamma</code> and <code>allprobs</code> are always reported by default when using <code>forward()</code> which is very useful for e.g.&nbsp;state decoding with <code>viterbi()</code>, because many downstream <code>LaMa</code> functions take these arguments as inputs. As the state-dependent parameters depend on the specific model formulation, these need to be reported manually by the user specifying the negative log-likelihood. Having all the parameters, we can plot the decoded time series</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>mod<span class="sc">$</span>states <span class="ot">=</span> <span class="fu">viterbi</span>(mod<span class="sc">$</span>delta, mod<span class="sc">$</span>Gamma, mod<span class="sc">$</span>allprobs)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"># defining color vector</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>color <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"orange"</span>, <span class="st">"deepskyblue"</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(elephant<span class="sc">$</span>step[<span class="dv">1</span><span class="sc">:</span><span class="dv">200</span>], <span class="at">type =</span> <span class="st">"h"</span>, <span class="at">xlab =</span> <span class="st">"time"</span>, <span class="at">ylab =</span> <span class="st">"step length"</span>, </span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>     <span class="at">col =</span> color[mod<span class="sc">$</span>states[<span class="dv">1</span><span class="sc">:</span><span class="dv">200</span>]], <span class="at">bty =</span> <span class="st">"n"</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>, <span class="at">col =</span> color, <span class="at">lwd =</span> <span class="dv">1</span>, <span class="at">legend =</span> <span class="fu">c</span>(<span class="st">"state 1"</span>, <span class="st">"state 2"</span>), <span class="at">bty =</span> <span class="st">"n"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="LaMa_and_RTMB_files/figure-html/decoding-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></p>
</figure>
</div>
</div>
</div>
<p>or the estimated state-dependent distributions.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>oldpar <span class="ot">=</span> <span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(elephant<span class="sc">$</span>step, <span class="at">prob =</span> <span class="cn">TRUE</span>, <span class="at">breaks =</span> <span class="dv">40</span>, </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">bor =</span> <span class="st">"white"</span>, <span class="at">main =</span> <span class="st">""</span>, <span class="at">xlab =</span> <span class="st">"step length"</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>) <span class="fu">curve</span>(delta[j] <span class="sc">*</span> <span class="fu">dgamma2</span>(x, mu[j], sigma[j]), </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>                    <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">add =</span> T, <span class="at">col =</span> color[j])</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="fu">curve</span>(delta[<span class="dv">1</span>]<span class="sc">*</span><span class="fu">dgamma2</span>(x, mu[<span class="dv">1</span>], sigma[<span class="dv">1</span>]) <span class="sc">+</span> delta[<span class="dv">2</span>]<span class="sc">*</span><span class="fu">dgamma2</span>(x, mu[<span class="dv">2</span>], sigma[<span class="dv">2</span>]), </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>      <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">lty =</span> <span class="dv">2</span>, <span class="at">add =</span> T)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"top"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">col =</span> color, <span class="at">legend =</span> <span class="fu">c</span>(<span class="st">"state 1"</span>, <span class="st">"state 2"</span>), <span class="at">bty =</span> <span class="st">"n"</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(elephant<span class="sc">$</span>angle, <span class="at">prob =</span> <span class="cn">TRUE</span>, <span class="at">breaks =</span> <span class="dv">40</span>, </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>     <span class="at">bor =</span> <span class="st">"white"</span>, <span class="at">main =</span> <span class="st">""</span>, <span class="at">xlab =</span> <span class="st">"turning angle"</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>) <span class="fu">curve</span>(delta[j] <span class="sc">*</span> <span class="fu">dvm</span>(x, <span class="dv">0</span>, kappa[j]), </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>                    <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">add =</span> T, <span class="at">col =</span> color[j])</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="fu">curve</span>(delta[<span class="dv">1</span>]<span class="sc">*</span><span class="fu">dvm</span>(x, <span class="dv">0</span>, kappa[<span class="dv">1</span>]) <span class="sc">+</span> delta[<span class="dv">2</span>]<span class="sc">*</span><span class="fu">dvm</span>(x, <span class="dv">0</span>, kappa[<span class="dv">2</span>]), </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>      <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">lty =</span> <span class="dv">2</span>, <span class="at">add =</span> T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="LaMa_and_RTMB_files/figure-html/statedepdist-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(oldpar) <span class="co"># resetting to default</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Lastly, we can also use the <code>sdreport()</code> function to directly give us standard errors for our unconstraint parameters and everything we <code>ADREPORT()</code>ed.&nbsp;</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>sdr <span class="ot">=</span> <span class="fu">sdreport</span>(obj)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can then get an overview of the estimated parameters and <code>ADREPORT()</code>ed quantities as well as their standard errors by</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(sdr)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;            Estimate  Std. Error</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; logmu    -1.1916144 0.011067932</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; logmu     0.9182131 0.008875692</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; logsigma -1.5995349 0.016232361</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; logsigma  0.3999258 0.013272894</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; logkappa -2.2872716 0.207126331</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; logkappa  0.4019563 0.019299344</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; eta      -1.6621910 0.041754277</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; eta      -1.5735921 0.040795512</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mu        0.3037305 0.003361669</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mu        2.5048106 0.022231928</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; sigma     0.2019904 0.003278782</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; sigma     1.4917139 0.019799361</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; kappa     0.1015431 0.021032256</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; kappa     1.4947460 0.028847617</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To get the estimated parameters or their standard errors in list format, type</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># estimated parameter in list format</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">as.list</span>(sdr, <span class="st">"Estimate"</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># parameter standard errors in list format</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">as.list</span>(sdr, <span class="st">"Std"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and to get the estimates and standard errors for <code>ADREPORT()</code>ed quantities in list format, type</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># adreported parameters as list</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">as.list</span>(sdr, <span class="st">"Estimate"</span>, <span class="at">report =</span> <span class="cn">TRUE</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co"># their standard errors</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="fu">as.list</span>(sdr, <span class="st">"Std"</span>, <span class="at">report =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="covariate-effects" class="level3">
<h3 class="anchored" data-anchor-id="covariate-effects">Covariate effects</h3>
<p>Generalizing to covariate effects is also straightforward. For example, we can add time of day variation to the state process. In this case we want to obtain a state process model of the form <span class="math display">\[
\text{logit}(\gamma_{ij}^{(t)}) = \beta_0^{(ij)} + \beta_1^{(ij)} \sin \bigl(\frac{2 \pi t}{24}\bigr) + \beta_2^{(ij)} \cos \bigl(\frac{2 \pi t}{24}\bigr) + \beta_3^{(ij)} \sin \bigl(\frac{2 \pi t}{12}\bigr) + \beta_4^{(ij)} \cos \bigl(\frac{2 \pi t}{12}\bigr),
\]</span> where <span class="math inline">\(t\)</span> is the time of day. For this we compute the trigonometric basis design matrix <code>Z</code> corresponding to above predictor and add the time of day to the <code>dat</code> list. The <code>LaMa</code> function <code>trigBasisExp()</code> does this very conveniently.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># building trigonometric basis desing matrix (in this case no intercept column)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>Z <span class="ot">=</span> <span class="fu">trigBasisExp</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">24</span>, <span class="at">degree =</span> <span class="dv">2</span>) <span class="co"># convenience function from LaMa</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>dat<span class="sc">$</span>Z <span class="ot">=</span> Z <span class="co"># adding design matrix to dat</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>dat<span class="sc">$</span>tod <span class="ot">=</span> elephant<span class="sc">$</span>tod <span class="co"># adding time of day to dat</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We also need to change the parameter list <code>par</code> to include the regression parameters for the time of day. The regression parameters for the state process will typically have the form of a <span class="math inline">\(N (N-1) \times p+1\)</span> matrix, where <span class="math inline">\(N\)</span> is the number of states and <span class="math inline">\(p\)</span> is the number of regressors – this format is also expected by <code>tpm_g()</code> which computes the array of transition matrices based on the design and parameter matrix. Another lovely convenience that <code>RTMB</code> allows for is that, in our parameter list, we can have matrices, making reshaping of vectors to matrices inside the likelihood function unnessesary.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>par <span class="ot">=</span> <span class="fu">list</span>(<span class="at">logmu =</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="fl">0.3</span>, <span class="dv">1</span>)), </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">logsigma =</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="fl">0.2</span>, <span class="fl">0.7</span>)),</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">logkappa =</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="fl">0.2</span>, <span class="fl">0.7</span>)),</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>           <span class="at">beta =</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="sc">-</span><span class="dv">2</span>, <span class="dv">2</span>), </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">rep</span>(<span class="dv">0</span>, <span class="dv">2</span><span class="sc">*</span><span class="fu">ncol</span>(Z))), <span class="at">nrow =</span> <span class="dv">2</span>)) <span class="co"># 2 times 4+1 matrix</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co"># replacing eta with regression parameter matrix, initializing slopes at zero</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now define a more general likelihood function with the main difference being the use of <code>tpm_g()</code> instead of <code>tpm()</code> and the inclusion of the time of day in the transition matrix calculation. This leads to us using <code>stationary_p()</code> instead of <code>stationary()</code> to calculate the initial distribuion and <code>forward_g()</code> instead of <code>forward()</code> to calculate the log-likelihood.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>mllk2 <span class="ot">=</span> <span class="cf">function</span>(par) {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">getAll</span>(par, dat) <span class="co"># makes everything contained available without $</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  Gamma <span class="ot">=</span> <span class="fu">tpm_g</span>(Z, beta, <span class="at">ad =</span> <span class="cn">TRUE</span>) <span class="co"># covariate-dependent tpms (in this case only 24 unique)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># tpm_g() automatically checks if intercept column is included</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ADREPORT</span>(Gamma) <span class="co"># adreporting</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  Delta <span class="ot">=</span> <span class="fu">stationary_p</span>(Gamma, <span class="at">ad =</span> <span class="cn">TRUE</span>) <span class="co"># periodically stationary dist</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ADREPORT</span>(Delta)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  delta <span class="ot">=</span> Delta[tod[<span class="dv">1</span>],]</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># exponentiating because all parameters strictly positive</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">=</span> <span class="fu">exp</span>(logmu); <span class="fu">REPORT</span>(mu)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>  sigma <span class="ot">=</span> <span class="fu">exp</span>(logsigma); <span class="fu">REPORT</span>(sigma)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>  kappa <span class="ot">=</span> <span class="fu">exp</span>(logkappa); <span class="fu">REPORT</span>(kappa)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># calculating all state-dependent densities</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>  allprobs <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">1</span>, <span class="at">nrow =</span> <span class="fu">length</span>(step), <span class="at">ncol =</span> N)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>  ind <span class="ot">=</span> <span class="fu">which</span>(<span class="sc">!</span><span class="fu">is.na</span>(step) <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.na</span>(angle)) <span class="co"># only for non-NA obs.</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N){</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    allprobs[ind,j] <span class="ot">=</span> <span class="fu">dgamma2</span>(step[ind],mu[j],sigma[j])<span class="sc">*</span><span class="fu">dvm</span>(angle[ind],<span class="dv">0</span>,kappa[j])</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>  <span class="sc">-</span><span class="fu">forward_g</span>(delta, Gamma[,,tod], allprobs, <span class="at">ad =</span> <span class="cn">TRUE</span>) <span class="co"># indexing 24 unique tpms by tod in data</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Having done this, the model fit is then essentially the same:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>obj2 <span class="ot">=</span> <span class="fu">MakeADFun</span>(mllk2, par, <span class="at">silent =</span> <span class="cn">TRUE</span>) <span class="co"># creating the objective function</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>opt2 <span class="ot">=</span> <span class="fu">nlminb</span>(obj2<span class="sc">$</span>par, obj2<span class="sc">$</span>fn, obj2<span class="sc">$</span>gr) <span class="co"># optimization</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And we can look at the reported results. In this case, for simplicity I get standard errors for <code>Gamma</code> with the delta method while, in general, this is not advisable.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>mod2 <span class="ot">=</span> obj2<span class="sc">$</span><span class="fu">report</span>()</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>sdr <span class="ot">=</span> <span class="fu">sdreport</span>(obj2)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>Gamma <span class="ot">=</span> <span class="fu">as.list</span>(sdr, <span class="st">"Estimate"</span>, <span class="at">report =</span> <span class="cn">TRUE</span>)<span class="sc">$</span>Gamma</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>Gammasd <span class="ot">=</span> <span class="fu">as.list</span>(sdr, <span class="st">"Std"</span>, <span class="at">report =</span> <span class="cn">TRUE</span>)<span class="sc">$</span>Gamma</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>Delta <span class="ot">=</span> <span class="fu">as.list</span>(sdr, <span class="st">"Estimate"</span>, <span class="at">report =</span> <span class="cn">TRUE</span>)<span class="sc">$</span>Delta</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>Deltasd <span class="ot">=</span> <span class="fu">as.list</span>(sdr, <span class="st">"Std"</span>, <span class="at">report =</span> <span class="cn">TRUE</span>)<span class="sc">$</span>Delta</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>tod_seq <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">24</span>, <span class="at">length =</span> <span class="dv">200</span>) <span class="co"># sequence for plotting</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>Z_pred <span class="ot">=</span> <span class="fu">trigBasisExp</span>(tod_seq, <span class="at">degree =</span> <span class="dv">2</span>) <span class="co"># design matrix for prediction</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>Gamma_plot <span class="ot">=</span> <span class="fu">tpm_g</span>(Z_pred, mod2<span class="sc">$</span>beta) <span class="co"># interpolating transition probs</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(tod_seq, Gamma_plot[<span class="dv">1</span>,<span class="dv">2</span>,], <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab =</span> <span class="st">"time of day"</span>, <span class="at">ylab =</span> <span class="st">"transition probability"</span>, <span class="at">bty =</span> <span class="st">"n"</span>)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="fu">segments</span>(<span class="at">x0 =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">24</span>, <span class="at">y0 =</span> Gamma[<span class="dv">1</span>,<span class="dv">2</span>,]<span class="sc">-</span><span class="fl">1.96</span><span class="sc">*</span>Gammasd[<span class="dv">1</span>,<span class="dv">2</span>,], </span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>         <span class="at">y1 =</span> Gamma[<span class="dv">1</span>,<span class="dv">2</span>,]<span class="sc">+</span><span class="fl">1.96</span><span class="sc">*</span>Gammasd[<span class="dv">1</span>,<span class="dv">2</span>,])</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a><span class="fu">segments</span>(<span class="at">x0 =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">24</span>, <span class="at">y0 =</span> Gamma[<span class="dv">2</span>,<span class="dv">1</span>,]<span class="sc">-</span><span class="fl">1.96</span><span class="sc">*</span>Gammasd[<span class="dv">2</span>,<span class="dv">1</span>,], </span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>         <span class="at">y1 =</span> Gamma[<span class="dv">2</span>,<span class="dv">1</span>,]<span class="sc">+</span><span class="fl">1.96</span><span class="sc">*</span>Gammasd[<span class="dv">2</span>,<span class="dv">1</span>,])</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(tod_seq, Gamma_plot[<span class="dv">2</span>,<span class="dv">1</span>,], <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">lty =</span> <span class="dv">3</span>)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topleft"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">lty =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>), <span class="at">bty =</span> <span class="st">"n"</span>,</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>       <span class="at">legend =</span> <span class="fu">c</span>(<span class="fu">expression</span>(gamma[<span class="dv">12</span>]<span class="sc">^</span>(t)), <span class="fu">expression</span>(gamma[<span class="dv">21</span>]<span class="sc">^</span>(t))))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="LaMa_and_RTMB_files/figure-html/MLE2-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Delta[,<span class="dv">2</span>], <span class="at">type =</span> <span class="st">"b"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">xlab =</span> <span class="st">"time of day"</span>, <span class="at">ylab =</span> <span class="st">"Pr(active)"</span>, </span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">col =</span> <span class="st">"deepskyblue"</span>, <span class="at">bty =</span> <span class="st">"n"</span>, <span class="at">xaxt =</span> <span class="st">"n"</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">segments</span>(<span class="at">x0 =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">24</span>, <span class="at">y0 =</span> Delta[,<span class="dv">2</span>]<span class="sc">-</span><span class="fl">1.96</span><span class="sc">*</span>Deltasd[,<span class="dv">2</span>], <span class="at">lwd =</span> <span class="dv">2</span>,</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">y1 =</span> Delta[,<span class="dv">2</span>]<span class="sc">+</span><span class="fl">1.96</span><span class="sc">*</span>Deltasd[,<span class="dv">2</span>], <span class="at">col =</span> <span class="st">"deepskyblue"</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="fu">axis</span>(<span class="dv">1</span>, <span class="at">at =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">24</span>,<span class="at">by=</span><span class="dv">4</span>), <span class="at">labels =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">24</span>,<span class="at">by=</span><span class="dv">4</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="LaMa_and_RTMB_files/figure-html/MLE2-2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="penalized-splines" class="level3">
<h3 class="anchored" data-anchor-id="penalized-splines">Penalized splines</h3>
<p>We can go one step further and model the transition probabilities as smooth functions of the time of day using cyclic P-splines, i.e. <span class="math display">\[
\text{logit}(\gamma_{ij}^{(t)}) = \beta_0^{(ij)} + s_{ij}(t),
\]</span> where <span class="math inline">\(s_{ij}(t)\)</span> is a smooth periodic function of time of day. <code>LaMa</code> provides the function <code>make_matrices()</code> which creates design and penalty matrices based on the R package <code>mgcv</code> when provided with a formula and data. Hence, we can use standard <code>mgcv</code> syntax to create the matrices for cyclic P-splines (<code>cp</code>). We then append both to the <code>dat</code> list.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>modmat <span class="ot">=</span> <span class="fu">make_matrices</span>(<span class="sc">~</span> <span class="fu">s</span>(tod, <span class="at">bs =</span> <span class="st">"cp"</span>), </span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">data =</span> <span class="fu">data.frame</span>(<span class="at">tod =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">24</span>),</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">knots =</span> <span class="fu">list</span>(<span class="at">tod =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">24</span>))) <span class="co"># where to wrap the cyclic basis</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>Z <span class="ot">=</span> modmat<span class="sc">$</span>Z <span class="co"># spline design matrix</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>S <span class="ot">=</span> modmat<span class="sc">$</span>S <span class="co"># penalty matrix</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>dat<span class="sc">$</span>Z <span class="ot">=</span> Z</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>dat<span class="sc">$</span>S <span class="ot">=</span> S[[<span class="dv">1</span>]] <span class="co"># mgcv returns a list </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We have to change our likelihood function slightly by adding the penalization. For this we use the <code>penalty()</code> function contained in <code>LaMa</code> that computes the sum of quadratic form penalties (the standard penalty used for penalized splines) based on the penalty matrices, the parameters to be estimated and the penalty strength parameters.</p>
<p>Importantly, we now have to separate the non-penalized intercept <code>beta0</code> from the penalized spline coefficients now called <code>betaspline</code>. The latter, we again conveniently initialize as a matrix, each row representing the coefficient vector for one off-diagonal element of the t.p.m.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>pnll <span class="ot">=</span> <span class="cf">function</span>(par) {</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">getAll</span>(par, dat) <span class="co"># makes everything contained available without $</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  Gamma <span class="ot">=</span> <span class="fu">tpm_g</span>(Z, <span class="fu">cbind</span>(beta0, betaspline), <span class="at">ad =</span> <span class="cn">TRUE</span>); <span class="fu">ADREPORT</span>(Gamma)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  Delta <span class="ot">=</span> <span class="fu">stationary_p</span>(Gamma, <span class="at">ad =</span> <span class="cn">TRUE</span>); <span class="fu">ADREPORT</span>(Delta)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  delta <span class="ot">=</span> Delta[tod[<span class="dv">1</span>],]</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># exponentiating because all parameters strictly positive</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">=</span> <span class="fu">exp</span>(logmu); <span class="fu">REPORT</span>(mu)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  sigma <span class="ot">=</span> <span class="fu">exp</span>(logsigma); <span class="fu">REPORT</span>(sigma)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  kappa <span class="ot">=</span> <span class="fu">exp</span>(logkappa); <span class="fu">REPORT</span>(kappa)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># calculating all state-dependent densities</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>  allprobs <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">1</span>, <span class="at">nrow =</span> <span class="fu">length</span>(step), <span class="at">ncol =</span> N)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>  ind <span class="ot">=</span> <span class="fu">which</span>(<span class="sc">!</span><span class="fu">is.na</span>(step) <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.na</span>(angle)) <span class="co"># only for non-NA obs.</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N){</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    allprobs[ind,j] <span class="ot">=</span> <span class="fu">dgamma2</span>(step[ind],mu[j],sigma[j])<span class="sc">*</span><span class="fu">dvm</span>(angle[ind],<span class="dv">0</span>,kappa[j])</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>  <span class="sc">-</span><span class="fu">forward_g</span>(delta, Gamma[,,tod], allprobs, <span class="at">ad =</span> <span class="cn">TRUE</span>) <span class="sc">+</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">penalty</span>(betaspline, S, lambda) <span class="co"># this does all the penalization work</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We also have to append a <code>lambda</code> argument to our <code>dat</code> list, which is the initial penalty strength parameter vector. In this case of length two because our coefficient matrix has two rows.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>par <span class="ot">=</span> <span class="fu">list</span>(<span class="at">logmu =</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="fl">0.3</span>, <span class="fl">2.5</span>)), </span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">logsigma =</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="fl">0.2</span>, <span class="fl">1.5</span>)),</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">logkappa =</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="fl">0.2</span>, <span class="fl">1.5</span>)),</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>           <span class="at">beta0 =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>, <span class="dv">2</span>), <span class="co"># intercept now separated!</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>           <span class="at">betaspline =</span> <span class="fu">matrix</span>(<span class="fu">rep</span>(<span class="dv">0</span>, <span class="dv">2</span><span class="sc">*</span>(<span class="fu">ncol</span>(Z)<span class="sc">-</span><span class="dv">1</span>)), <span class="at">nrow =</span> <span class="dv">2</span>))</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>dat<span class="sc">$</span>lambda <span class="ot">=</span> <span class="fu">rep</span>(<span class="dv">100</span>, <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The model fit can then be conducted by using the <code>qreml()</code> function contained in <code>LaMa</code>, qREML standing for penalized quasi-likelihood. Under the hood, <code>qreml()</code> also constructs an AD function with <code>RTMB</code> but uses the qREML algorithm described in Koslik, 2024 to fit the model. We have to tell the <code>qreml()</code> function which parameters are spline coefficients by providing the name of the corresponding list element of <code>par</code>.</p>
<p>There are some rules to follow when using <code>qreml()</code>:</p>
<ol type="1">
<li>The likelihood function needs to be <code>RTMB</code>-compatible, i.e.&nbsp;have the same structure as all the likelihood functions in our vignette – most importantly, it should only be a function of the parameter list.</li>
<li>The penalty strength vector <code>lambda</code> needs its length to correspond to the <em>total</em> number of spline coefficient vectors used. In our case, this is the number of rows of betaspline, but if we additionally had a different spline coefficient in our parameter list (that may have a different length and a differnt penalty matrix), we would have needed more elements in <code>lambda</code>.</li>
<li>The <code>penalty()</code> function can only be called <em>once</em> in the likelihood. If several spline coefficients are penalized, <code>penalty()</code> expects a list of coefficient matrices or vectors and a list of penalty matrices.</li>
<li>When we summarise multiple spline coefficients in a matrix in our parameter list – which is very useful when these are of same lengths and have the same penalty matrix – this matrix must be arranged by row, i.e.&nbsp;each row is one spline coefficient vector. If it is arranged by column, <code>qreml()</code> will fail.</li>
</ol>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  mod3 <span class="ot">&lt;-</span> <span class="fu">qreml</span>(pnll, par, dat, <span class="at">random =</span> <span class="st">"betaspline"</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Creating AD function</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Initializing with lambda: 100 100 </span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; outer 1 - lambda: 2.93 2.612 </span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; outer 2 - lambda: 0.417 0.423 </span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; outer 3 - lambda: 0.311 0.162 </span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; outer 4 - lambda: 0.308 0.121 </span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; outer 5 - lambda: 0.308 0.113 </span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; outer 6 - lambda: 0.308 0.113 </span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; outer 7 - lambda: 0.308 0.113 </span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Converged</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   6.174   0.064   6.306</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <code>mod</code> object is now a list that contains everything that is reported by the likelihood function, but also the <code>RTMB</code> object created in the process. After fitting the model, we can also use the <code>LaMa</code> function <code>pred_matrix()</code>, that takes the <code>modmat</code> object we created earlier, to build a new interpolating design matrix using the exact same basis expansion specified above. This allows us to plot the estimated transition probabilities as a smooth function of time of day – I now ignore confidence bands due to laziness.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>sdr <span class="ot">=</span> <span class="fu">sdreport</span>(mod3<span class="sc">$</span>obj)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>Gamma <span class="ot">=</span> <span class="fu">as.list</span>(sdr, <span class="st">"Estimate"</span>, <span class="at">report =</span> <span class="cn">TRUE</span>)<span class="sc">$</span>Gamma</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>Delta <span class="ot">=</span> <span class="fu">as.list</span>(sdr, <span class="st">"Estimate"</span>, <span class="at">report =</span> <span class="cn">TRUE</span>)<span class="sc">$</span>Delta</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>tod_seq <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">24</span>, <span class="at">length=</span><span class="dv">200</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>Z_pred <span class="ot">=</span> <span class="fu">pred_matrix</span>(modmat, <span class="fu">data.frame</span>(<span class="at">tod =</span> tod_seq))</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>Gamma_plot <span class="ot">=</span> <span class="fu">tpm_g</span>(Z_pred, mod3<span class="sc">$</span>beta) <span class="co"># interpolating transition probs</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(tod_seq, Gamma_plot[<span class="dv">1</span>,<span class="dv">2</span>,], <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab =</span> <span class="st">"time of day"</span>, <span class="at">ylab =</span> <span class="st">"transition probability"</span>, <span class="at">bty =</span> <span class="st">"n"</span>)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(tod_seq, Gamma_plot[<span class="dv">2</span>,<span class="dv">1</span>,], <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">lty =</span> <span class="dv">3</span>)</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topleft"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">lty =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>), <span class="at">bty =</span> <span class="st">"n"</span>,</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>       <span class="at">legend =</span> <span class="fu">c</span>(<span class="fu">expression</span>(gamma[<span class="dv">12</span>]<span class="sc">^</span>(t)), <span class="fu">expression</span>(gamma[<span class="dv">21</span>]<span class="sc">^</span>(t))))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="LaMa_and_RTMB_files/figure-html/results%20qreml-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Delta[,<span class="dv">2</span>], <span class="at">type =</span> <span class="st">"b"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">xlab =</span> <span class="st">"time of day"</span>, <span class="at">ylab =</span> <span class="st">"Pr(active)"</span>, </span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">col =</span> <span class="st">"deepskyblue"</span>, <span class="at">bty =</span> <span class="st">"n"</span>, <span class="at">xaxt =</span> <span class="st">"n"</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="fu">axis</span>(<span class="dv">1</span>, <span class="at">at =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">24</span>,<span class="at">by=</span><span class="dv">4</span>), <span class="at">labels =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">24</span>,<span class="at">by=</span><span class="dv">4</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="LaMa_and_RTMB_files/figure-html/results%20qreml-2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></p>
</figure>
</div>
</div>
</div>
<p>We see that by allowing for a more flexible relationship, the estimated time of day effect becomes stronger with even sharper peaks than we would have concluded using the trigonometric approach.</p>
</section>
<section id="full-laplace-method" class="level3">
<h3 class="anchored" data-anchor-id="full-laplace-method">Full Laplace method</h3>
<p>Lastly, we could have achieved the fit above using the slightly more accurate full Laplace approximation method which can be used to fit models via marginal maximum likelihood estimation by integrating random effects. This is natively supported by <code>RTMB</code> – and actually one of its core selling points and the standard way we can now deal with general random effects.</p>
<p>Indeed, the qREML algorithm above treats the spline coefficients as Gaussian random effects but exploits their relatively simple structure yiedling a more efficient fitting method. The full Laplace method is much more general, allowing for very flexible random effects, but here, estimation slower because it does not exploit the simple structure of splines treated as random effects.</p>
<p>We have to alter our likelihood function slightly, because for the Laplace method, we need to implement the joint likelihood of the data and the random effect, the latter having a multivariate normal distribution. Specifically, if <span class="math inline">\(b\)</span> is our random effect for a spline, <span class="math inline">\(b \sim N(0, \lambda^{-1} S^-)\)</span>. The likelihood of the data given <span class="math inline">\(b\)</span> (just our regular likelihoot that treats <span class="math inline">\(b\)</span> as a parameter) is <span class="math inline">\(f(x \mid b)\)</span> and the density of <span class="math inline">\(b\)</span> is <span class="math inline">\(f_{\lambda}(b)\)</span>. Hence the joint likelihood can be computed as <span class="math display">\[
f(x, b) = f(x \mid b) f_{\lambda}(b)
\]</span> and the joint negative log-likelihood becomes <span class="math inline">\(- \log f(x \mid b) - \log f_{\lambda}(b)\)</span> and this is what we implement below.</p>
<p>Most conveniently this is done by using the <code>dgmrf2()</code> function included in <code>LaMa</code> which provides the density function of the multivariate normal distribution reparametrized in terms of the (scaled) precision matrix, i.e.&nbsp;inverse covariance matrix, which in our case is <span class="math inline">\(\lambda_i S\)</span> for spline <span class="math inline">\(i\)</span>. It allows evaluating at multiple points at once, each one possibly with its own penalty strength parameter <code>lambda</code>. It differs from <code>RTMB</code>’s <code>dgmrf()</code> by not expecting a <em>sparse</em> precision matrix and being more robust for rank-deficient penalty matrices, which are typical for penalized splines.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>jnll <span class="ot">=</span> <span class="cf">function</span>(par) {</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">getAll</span>(par, dat) <span class="co"># makes everything contained available without $</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  Gamma <span class="ot">=</span> <span class="fu">tpm_g</span>(Z, <span class="fu">cbind</span>(beta0, betaspline), <span class="at">ad =</span> <span class="cn">TRUE</span>); <span class="fu">ADREPORT</span>(Gamma)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  Delta <span class="ot">=</span> <span class="fu">stationary_p</span>(Gamma, <span class="at">ad =</span> <span class="cn">TRUE</span>); <span class="fu">ADREPORT</span>(Delta)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  delta <span class="ot">=</span> Delta[tod[<span class="dv">1</span>],]</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># exponentiating because all parameters strictly positive</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">=</span> <span class="fu">exp</span>(logmu); <span class="fu">REPORT</span>(mu)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  sigma <span class="ot">=</span> <span class="fu">exp</span>(logsigma); <span class="fu">REPORT</span>(sigma)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>  kappa <span class="ot">=</span> <span class="fu">exp</span>(logkappa); <span class="fu">REPORT</span>(kappa)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># calculating all state-dependent densities</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>  allprobs <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">1</span>, <span class="at">nrow =</span> <span class="fu">length</span>(step), <span class="at">ncol =</span> N)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>  ind <span class="ot">=</span> <span class="fu">which</span>(<span class="sc">!</span><span class="fu">is.na</span>(step) <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.na</span>(angle)) <span class="co"># only for non-NA obs.</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N){</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    allprobs[ind,j] <span class="ot">=</span> <span class="fu">dgamma2</span>(step[ind],mu[j],sigma[j])<span class="sc">*</span><span class="fu">dvm</span>(angle[ind],<span class="dv">0</span>,kappa[j])</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>  <span class="sc">-</span><span class="fu">forward_g</span>(delta, Gamma[,,tod], allprobs, <span class="at">ad =</span> <span class="cn">TRUE</span>) <span class="sc">-</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sum</span>(<span class="fu">dgmrf2</span>(betaspline, <span class="dv">0</span>, S, <span class="fu">exp</span>(loglambda), <span class="at">log =</span> <span class="cn">TRUE</span>)) <span class="co"># just like any other density in R</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We also have to include the log of our penalty strength as a parameter now.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>par<span class="sc">$</span>loglambda <span class="ot">=</span> <span class="fu">log</span>(<span class="fu">rep</span>(<span class="dv">100</span>, <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To create the objective function, we need to tell <code>RTMB</code> that <code>betaspline</code> is a random effect such that it is integrated out and as our objective function we have the marginal likelihood <span class="math display">\[
f(x) = \int f(x, b) \,db,
\]</span> actually its negative log of course.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>obj4 <span class="ot">=</span> <span class="fu">MakeADFun</span>(jnll, par, <span class="at">random =</span> <span class="st">"betaspline"</span>, <span class="at">silent =</span> <span class="cn">TRUE</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  opt4 <span class="ot">&lt;-</span> <span class="fu">nlminb</span>(obj4<span class="sc">$</span>par, obj4<span class="sc">$</span>fn, obj4<span class="sc">$</span>gr)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 108.533   0.878 109.934</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As we can see, the results are basically identical while the model fit took more than ten times as long.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>mod4 <span class="ot">=</span> obj4<span class="sc">$</span><span class="fu">report</span>()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>mod4<span class="sc">$</span>Gamma <span class="ot">=</span> <span class="fu">tpm_g</span>(Z, mod4<span class="sc">$</span>beta) <span class="co"># calculating 24 tpms</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>Gamma_plot <span class="ot">=</span> <span class="fu">tpm_g</span>(Z_pred, mod4<span class="sc">$</span>beta)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(tod_seq, Gamma_plot[<span class="dv">1</span>,<span class="dv">2</span>,], <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab =</span> <span class="st">"time of day"</span>, <span class="at">ylab =</span> <span class="st">"transition probability"</span>, <span class="at">bty =</span> <span class="st">"n"</span>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(tod_seq, Gamma_plot[<span class="dv">2</span>,<span class="dv">1</span>,], <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">lty =</span> <span class="dv">3</span>)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topleft"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">lty =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>), <span class="at">bty =</span> <span class="st">"n"</span>,</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>       <span class="at">legend =</span> <span class="fu">c</span>(<span class="fu">expression</span>(gamma[<span class="dv">12</span>]<span class="sc">^</span>(t)), <span class="fu">expression</span>(gamma[<span class="dv">21</span>]<span class="sc">^</span>(t))))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="LaMa_and_RTMB_files/figure-html/results%20refit-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="common-issues-with-rtmb" class="level3">
<h3 class="anchored" data-anchor-id="common-issues-with-rtmb">Common issues with <code>RTMB</code></h3>
<p>There are some problems with <code>RTMB</code> one has to keep in mind. They can be a bit annoying, but in my opinion the benefits of automatic differentiation far outweigh the drawbacks. I list the main ones I have encountered here, but please tell me if you encounter more, such that they can be added.</p>
<p>A typical issue with <code>RTMB</code> is that some operators might need to be overloaded to allow for automatic differentiation which cannot be done by default. In typical model setups <code>LaMa</code> functions do this themselves, but if you go a very individualistic route and get an error like</p>
<div class="cell" data-layout-align="center">
<pre><code>#&gt; Error: Invalid argument to 'advector' (lost class attribute?)</code></pre>
</div>
<p>you might have to overload the operator yourself. To do this put</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="st">"[&lt;-"</span> <span class="ot">&lt;-</span> <span class="fu">ADoverload</span>(<span class="st">"[&lt;-"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>as the first line of your likelihood function. If the error still prevails also add</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="st">"c"</span> <span class="ot">&lt;-</span> <span class="fu">ADoverload</span>(<span class="st">"c"</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="st">"diag&lt;-"</span> <span class="ot">&lt;-</span> <span class="fu">ADoverload</span>(<span class="st">"diag&lt;-"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>which should hopefully fix the error.</p>
<p>Another common problem occurs when initiating objects with <code>NA</code> values and then trying to fill them with <code>numeric</code> values. This is because <code>NA</code> is logical which screws up the automatic differentiation due to the mismatching types. To avoid this, always initiate with <code>numeric</code> or <code>NaN</code> values. For example, don’t do</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>X <span class="ot">=</span> <span class="fu">array</span>(<span class="at">dim =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>))</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co"># which is the same as</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>X <span class="ot">=</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>but rather</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>X <span class="ot">=</span> <span class="fu">array</span>(<span class="cn">NaN</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>))</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co"># or</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>X <span class="ot">=</span> <span class="fu">array</span>(<span class="dv">0</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>to avoid the error.</p>
<p>Furthermore, there are some unfortunate side effects of R’s ‘byte compiler’ (enabled by default in R). So if you encounter an error not matching the previous ones, try disabling the byte compiler with</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>compiler<span class="sc">::</span><span class="fu">enableJIT</span>(<span class="dv">0</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 3</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and see if the error is resolved.</p>
<p>Some more minor things:</p>
<ul>
<li>if you’re used to <code>expm::expm()</code> that won’t work with AD. Use <code>Matrix::expm()</code> instead.</li>
<li><code>CircStats::dvm()</code> also isn’t compatible with AD. Use <code>LaMa::dvm()</code> instead.</li>
<li>you can use <code>if</code> statements in your likelihood function, but <em>not</em> on the parameter itself as this will obviously not be differentiable.</li>
<li>most of the standard distributions are available in <code>RTMB</code>. If you need a non-standard one, try implementing the density function yourself using plain R code. <code>RTMB</code> also provides AD versions of many building-block functions (like the Gamma or Bessel function) which might help with this.</li>
</ul>
<p>For more information on <code>RTMB</code>, check out its <a href="https://cran.r-project.org/web/packages/RTMB/index.html">documentation</a> or the <a href="https://groups.google.com/g/tmb-users">TMB users Google group</a>.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>
<script>window.backupDefine = window.define; window.define = undefined;</script>
<script type="text/javascript" src="quarto-preview.js"></script>
<script>window.define = window.backupDefine; window.backupDefine = undefined;</script>
<script type="text/javascript">
  const options = {
    origin: "",
    search: "",
    inputFile: "/Users/jan-ole/R/Packages_on_Git/LaMa/vignettes/LaMa_and_RTMB.qmd",
    isPresentation: false
  }
  document.addEventListener("DOMContentLoaded", function () {
    window.QuartoPreview.init(options);
  });
</script>
